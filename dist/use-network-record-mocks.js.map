{
  "version": 3,
  "sources": ["../src/use-network-record-mocks.ts"],
  "sourcesContent": ["import { Page } from \"@playwright/test\";\nimport fs from \"fs\";\n\nimport { RecordRequest } from \"./models\";\nimport { readHarFile, recordHar } from \"./recorder\";\nimport { getCallerFile, mockRequests, readFile, writeFile } from \"./utils\";\n\nconst mergeOverriddenResponses = (\n  override: { [key: string]: any },\n  requests: RecordRequest[]\n): RecordRequest[] => {\n  return requests.map((r) => ({\n    ...r,\n    response: override[r.url] || r.response,\n  }));\n};\n\n/**\n *\n * @param identifier For when you need to have more than one Mock version for a single .spec, it will look for a file containing such identifier (e.g. for test.specs.ts, and identifier \"test2\", it will look for ``test.spec.test2.mocks.json``).\n * @param recordRoute When recording a new network mock file, it will use this path to open the new page.\n * @param logRecording When recording a new network mock file, enables console logging of every xhr request happening.\n * @param overrideResponses To use other values instead of the ones recorded for given tests.\n *\n *  ```e.g. { [\"/url_to_override\"]: myCustomMockData }```\n * @returns\n */\nexport const useNetworkRecordMocks = async (\n  page: Page,\n  configs: {\n    identifier?: string;\n    recordRoute?: string;\n    logRecording?: boolean;\n    fileName?: string;\n    urlPattern?: string;\n    overrideResponses?: { [key: string]: any };\n  } = {}\n): Promise<RecordRequest[]> => {\n  const { identifier, recordRoute, logRecording, overrideResponses, fileName, urlPattern } =\n    configs || {};\n\n  const basePath = fileName ? fileName : `${getCallerFile().replace(\".ts\", \"\").replace(\".js\", \"\")}${identifier ? `.${identifier}` : \"\"\n    }`;\n\n  const path = `${basePath}.mocks.json`;\n\n  let requests: RecordRequest[] = [];\n  let patternRegExp;\n\n  if (urlPattern) {\n    patternRegExp = new RegExp(urlPattern)\n  }\n\n  if (fs.existsSync(path)) {\n    console.log(`Using \"${path}\" for network request mocks.`);\n    requests = await readFile(path);\n  } else if (fs.existsSync(`${basePath}.har`)) {\n    console.log(`A HAR file was found for \"${basePath}\", creating a mock file and using it.`);\n\n    requests = await readHarFile(`${basePath}.har`, recordRoute, patternRegExp);\n    await writeFile(path, requests);\n  } else {\n    console.log(\n      `Mocks file not found${identifier ? ` for ${identifier}` : \"\"\n      }, recording a new one!`\n    );\n\n    requests = await recordHar(recordRoute, patternRegExp, path, logRecording);\n  }\n\n  if (!!overrideResponses) {\n    requests = mergeOverriddenResponses(overrideResponses, requests);\n  }\n\n  await mockRequests(requests, page);\n\n  return requests;\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AACA,gBAAe;AAGf,sBAAuC;AACvC,mBAAiE;AAEjE,MAAM,2BAA2B,CAC/B,UACA,aACoB;AACpB,SAAO,SAAS,IAAI,CAAC,MAAO,iCACvB,IADuB;AAAA,IAE1B,UAAU,SAAS,EAAE,QAAQ,EAAE;AAAA;AAAA;AAc5B,MAAM,wBAAwB,CACnC,OAS6B,wBAT7B,IAS6B,mBAT7B,MACA,UAOI,IACyB;AAC7B,QAAM,EAAE,YAAY,aAAa,cAAc,mBAAmB,UAAU,eAC1E,WAAW;AAEb,QAAM,WAAW,WAAW,WAAW,GAAG,kCAAgB,QAAQ,OAAO,IAAI,QAAQ,OAAO,MAAM,aAAa,IAAI,eAAe;AAGlI,QAAM,OAAO,GAAG;AAEhB,MAAI,WAA4B;AAChC,MAAI;AAEJ,MAAI,YAAY;AACd,oBAAgB,IAAI,OAAO;AAAA;AAG7B,MAAI,kBAAG,WAAW,OAAO;AACvB,YAAQ,IAAI,UAAU;AACtB,eAAW,MAAM,2BAAS;AAAA,aACjB,kBAAG,WAAW,GAAG,iBAAiB;AAC3C,YAAQ,IAAI,6BAA6B;AAEzC,eAAW,MAAM,iCAAY,GAAG,gBAAgB,aAAa;AAC7D,UAAM,4BAAU,MAAM;AAAA,SACjB;AACL,YAAQ,IACN,uBAAuB,aAAa,QAAQ,eAAe;AAI7D,eAAW,MAAM,+BAAU,aAAa,eAAe,MAAM;AAAA;AAG/D,MAAI,CAAC,CAAC,mBAAmB;AACvB,eAAW,yBAAyB,mBAAmB;AAAA;AAGzD,QAAM,+BAAa,UAAU;AAE7B,SAAO;AAAA;",
  "names": []
}
